<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ç²’å­è¡¨ç™½ç³»ç»Ÿ - ç¨³å®šäº¤äº’ç‰ˆ</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Microsoft YaHei', sans-serif; 
            -webkit-user-select: none;  /* Safariæ”¯æŒ */
            user-select: none; /* å…¶ä»–æµè§ˆå™¨æ”¯æŒ */
        }

        /* çŠ¶æ€æ˜¾ç¤º HUD */
        #hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            pointer-events: none;
            user-select: none;
            z-index: 10;
            width: 220px;
        }

        #hud-status { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #hud-detail { font-size: 12px; color: #aaa; line-height: 1.5; }

        /* è¾“å…¥é¢æ¿ */
        #input-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 280px;
            z-index: 10;
            transition: opacity 0.3s;
            opacity: 0.3;
        }

        #input-panel:hover { opacity: 1; }

        input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background: rgba(0,0,0,0.5);
            color: white;
            box-sizing: border-box;
        }

        label {
            font-size: 12px;
            color: #aaa;
            display: block;
            margin-bottom: 5px;
        }
        
        /* éšè—çš„æ‘„åƒå¤´è§†é¢‘ */
        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            z-index: -1;
            pointer-events: none;
            transform: translate3d(0, 0, 0); /* ä¼˜åŒ–æ€§èƒ½ */
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <h2>ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</h2>
        <p>æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´ä¸ AI æ¨¡å‹</p>
        <p style="font-size:12px; color:#666">è¯·ç¡®ä¿ä½¿ç”¨ https æˆ– localhost è®¿é—®</p>
    </div>

    <div id="hud-panel">
        <div id="hud-status">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="hud-detail">
            ğŸ‘† å•æŒ‡ï¼šæ¨±èŠ±é›¨ + "å¼€å¼€å¿ƒå¿ƒ"<br>
            âœŒï¸ åŒæŒ‡ï¼šæ¨±èŠ±é›¨ + "å¥½å¥½çˆ±è‡ªå·±"<br>
            âœ‹ ä¸‰æŒ‡ï¼šèŠ±ç“£é›¨ + "ä»Šå¤©å¾ˆå“‡å¡"<br>
            ğŸ– å¼ æ‰‹ï¼šå˜çˆ±å¿ƒ<br>
            âœŠ æ¡æ‹³ï¼šçˆ†ç‚¸ + "æˆ‘çœŸçš„å¾ˆæ£’"
        </div>
    </div>

    <div id="input-panel">
        <label>åå­—</label>
        <input type="text" id="input-name" value="ç‹æ ‡">
        <label>è¡¨ç™½å†…å®¹</label>
        <input type="text" id="input-msg" value="æˆ‘æ°¸è¿œçˆ±ä½ ">
        <div style="font-size:10px; color:#666; margin-top:5px;">* é¼ æ ‡æ‚¬åœå¯ä¿®æ”¹å†…å®¹</div>
    </div>

    <video id="video-feed" playsinline autoplay muted></video>

<script>
// --- æ ¸å¿ƒé…ç½® ---
const PARTICLE_COUNT = 30000;
const PARTICLE_SIZE = 0.18;

// --- å…¨å±€å˜é‡ ---
let scene, camera, renderer, particles;
let particlePositions, colors, targetPositions;
let geometry;

// çŠ¶æ€æ§åˆ¶
let isExploding = false;
let explosionVelocities = [];
let isTextState = false; // æ§åˆ¶æ˜¯å¦éœ€è¦æ™ºèƒ½å›æ­£

// ç”»å¸ƒç›¸å…³
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// æ‰‹åŠ¿çŠ¶æ€æœº
let lastGesture = 'none';
let gestureFrameCount = 0;
const GESTURE_THRESHOLD = 10;

// å¯åŠ¨å…¥å£
initThree();
initMediaPipe();
animate();

// =========================================================
// 1. THREE.JS ç²’å­ç³»ç»Ÿéƒ¨åˆ†
// =========================================================
function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 35;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    initParticles();
    calculateSpherePositions(); 
    window.addEventListener('resize', onWindowResize);
}

function initParticles() {
    geometry = new THREE.BufferGeometry();
    particlePositions = new Float32Array(PARTICLE_COUNT * 3);
    colors = new Float32Array(PARTICLE_COUNT * 3);
    targetPositions = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        particlePositions[i*3] = (Math.random()-0.5)*50;
        particlePositions[i*3+1] = (Math.random()-0.5)*50;
        particlePositions[i*3+2] = (Math.random()-0.5)*50;
        colors[i*3] = 0; colors[i*3+1] = 0.8; colors[i*3+2] = 1;
        explosionVelocities.push({x:0, y:0, z:0});
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);
}

// --- æ™ºèƒ½æ–‡å­—è½¬ç²’å­ç®—æ³• ---
function getTextPositions(textStr, fontSize = 100) {
    ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
    const textWidth = Math.ceil(ctx.measureText(textStr).width);
    
    const dynamicWidth = textWidth + 60;
    const dynamicHeight = Math.max(fontSize * 1.5, 200);
    
    canvas.width = dynamicWidth;
    canvas.height = dynamicHeight;

    ctx.clearRect(0, 0, dynamicWidth, dynamicHeight);
    ctx.fillStyle = 'white';
    ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(textStr, dynamicWidth / 2, dynamicHeight / 2);

    const data = ctx.getImageData(0, 0, dynamicWidth, dynamicHeight).data;
    const validPositions = [];

    for (let y = 0; y < dynamicHeight; y += 2) { 
        for (let x = 0; x < dynamicWidth; x += 2) {
            if (data[(y * dynamicWidth + x) * 4 + 3] > 128) {
                const posX = (x - dynamicWidth / 2) * 0.15;
                const posY = -(y - dynamicHeight / 2) * 0.15;
                for(let k=0; k<3; k++) {
                    validPositions.push({
                        x: posX,
                        y: posY,
                        z: (Math.random() - 0.5) * 2.5 
                    });
                }
            }
        }
    }
    return validPositions;
}

function getHeartPositions() {
    const points = [];
    for (let i = 0; i < 9000; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random());
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        let z = r * 6 * Math.sin(Math.random() * Math.PI * 2) * Math.cos(t);
        x *= 0.35; y *= 0.35; z *= 0.35; y += 2;
        points.push({x, y, z});
    }
    return points;
}

// --- å˜å½¢æ ¸å¿ƒé€»è¾‘ ---
function morphTo(newPoints, colorHex, isText = false) {
    isExploding = false;
    isTextState = isText;
    
    const colorObj = new THREE.Color(colorHex);
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        if (i < newPoints.length) {
            targetPositions[i*3] = newPoints[i].x;
            targetPositions[i*3+1] = newPoints[i].y;
            targetPositions[i*3+2] = newPoints[i].z;
        } else {
            targetPositions[i*3] = (Math.random()-0.5) * 90;
            targetPositions[i*3+1] = (Math.random()-0.5) * 90;
            targetPositions[i*3+2] = (Math.random()-0.5) * 90;
        }
    }

    const startColor = { r: colors[0], g: colors[1], b: colors[2] };
    new TWEEN.Tween(startColor)
        .to({ r: colorObj.r, g: colorObj.g, b: colorObj.b }, 1000)
        .onUpdate(() => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const dim = (i < newPoints.length) ? 1.0 : 0.15; 
                colors[i*3] = startColor.r * dim;
                colors[i*3+1] = startColor.g * dim;
                colors[i*3+2] = startColor.b * dim;
            }
            geometry.attributes.color.needsUpdate = true;
        })
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();
}

// --- é¢„è®¾åŠ¨ä½œå°è£… ---
function showCharacter(index) {
    const name = document.getElementById('input-name').value;
    const char = name[index] || name[name.length-1];
    morphTo(getTextPositions(char, 120), 0x00ffff, true); 
}

function showFullName() {
    const name = document.getElementById('input-name').value;
    morphTo(getTextPositions(name, 80), 0x00ffff, true);
}

function morphToHeart() {
    morphTo(getHeartPositions(), 0xff0044, false); 
}

function calculateSpherePositions() {
    const points = [];
    for (let i=0; i<5000; i++) {
         points.push({x:(Math.random()-0.5)*30, y:(Math.random()-0.5)*30, z:(Math.random()-0.5)*30});
    }
    morphTo(points, 0x00ffff, false);
}

function explodeAndShowMsg() {
    if (isExploding) return;
    isExploding = true;
    isTextState = false; 
    
    for(let i=0; i<PARTICLE_COUNT; i++) {
        explosionVelocities[i].x = (Math.random() - 0.5) * 3.5;
        explosionVelocities[i].y = (Math.random() - 0.5) * 3.5;
        explosionVelocities[i].z = (Math.random() - 0.5) * 3.5;
    }

    setTimeout(() => {
        const msg = document.getElementById('input-msg').value;
        morphTo(getTextPositions(msg, 60), 0xff88aa, true); 
    }, 1200);
}

// =========================================================
// 2. AI æ‰‹åŠ¿è¯†åˆ«éƒ¨åˆ†
// =========================================================
function initMediaPipe() {
    const videoElement = document.getElementById('video-feed');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });

    cameraUtils.start()
        .then(() => {
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(()=>loader.remove(), 500);
        })
        .catch(err => {
            console.error(err);
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ– HTTPS ç¯å¢ƒ");
        });
}

function onHandsResults(results) {
    let detectedGesture = 'none';
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const lm = results.multiHandLandmarks[0];
        let fingerCount = 0;
        
        // ç®€æ˜“æ‰‹æŒ‡è®¡æ•°é€»è¾‘
        if (lm[8].y < lm[6].y) fingerCount++; // é£ŸæŒ‡
        if (lm[12].y < lm[10].y) fingerCount++; // ä¸­æŒ‡
        if (lm[16].y < lm[14].y) fingerCount++; // æ— åæŒ‡
        if (lm[20].y < lm[18].y) fingerCount++; // å°æŒ‡
        if (Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x)) fingerCount++; // æ‹‡æŒ‡

        // --- çŠ¶æ€åˆ†ç±» ---
        if (fingerCount === 1) detectedGesture = 'one';
        else if (fingerCount === 2) detectedGesture = 'two';
        else if (fingerCount === 3) detectedGesture = 'three'; // å¤„ç†ä¸‰æŒ‡
        else if (fingerCount >= 4) detectedGesture = 'open'; // 4æŒ‡æˆ–5æŒ‡éƒ½ç®—å¼ å¼€
    }

    // é˜²æŠ–é€»è¾‘
    if (detectedGesture === lastGesture) {
        gestureFrameCount++;
    } else {
        gestureFrameCount = 0;
        lastGesture = detectedGesture;
    }

    if (gestureFrameCount === GESTURE_THRESHOLD) {
        handleGestureAction(detectedGesture);
    }
}

function handleGestureAction(gesture) {
    const statusDiv = document.getElementById('hud-status');

    switch(gesture) {
        case 'one':
            statusDiv.innerText = "ğŸ‘† è¯†åˆ«ï¼šå•æŒ‡";
            statusDiv.style.color = "#00ffff";
            morphToHeart(); // æ¨±èŠ±é›¨ + "å¼€å¼€å¿ƒå¿ƒ"
            break;
        case 'two':
            statusDiv.innerText = "âœŒï¸ è¯†åˆ«ï¼šåŒæŒ‡";
            statusDiv.style.color = "#00ffff";
            morphToHeart(); // æ¨±èŠ±é›¨ + "å¥½å¥½çˆ±è‡ªå·±"
            break;
        case 'three':
            statusDiv.innerText = "âœ‹ è¯†åˆ«ï¼šä¸‰æŒ‡";
            statusDiv.style.color = "#00ffff";
            morphToHeart(); // èŠ±ç“£é›¨ + "ä»Šå¤©å¾ˆå“‡å¡"
            break;
        case 'open':
            statusDiv.innerText = "ğŸ– è¯†åˆ«ï¼šå¼ æ‰‹";
            statusDiv.style.color = "#ff0044";
            morphToHeart();
            break;
        case 'fist':
            statusDiv.innerText = "âœŠ è¯†åˆ«ï¼šæ¡æ‹³";
            statusDiv.style.color = "#ffaa00";
            explodeAndShowMsg(); // çˆ†ç‚¸ + "æˆ‘çœŸçš„å¾ˆæ£’"
            break;
    }
}

// =========================================================
// 3. åŠ¨ç”»å¾ªç¯
// =========================================================
function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();

    const positions = geometry.attributes.position.array;

    // --- æ™ºèƒ½æ—‹è½¬é€»è¾‘ ---
    if (isTextState) {
        // æ–‡å­—çŠ¶æ€ï¼šå¹³æ»‘å›æ­£ + å¾®å¹…å‘¼å¸æ‘†åŠ¨
        const targetRotation = Math.sin(Date.now() * 0.001) * 0.2;
        camera.rotation.y += (targetRotation - camera.rotation.y) * 0.05;
    } else {
        // ç²’å­æ—‹è½¬
        camera.rotation.y += 0.002;
    }

    renderer.render(scene, camera);
}
</script>

</body>
</html>
