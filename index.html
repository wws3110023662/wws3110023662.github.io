<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ç²’å­å¿ƒæƒ…ç³»ç»Ÿ - ç§¯æèƒ½é‡ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft YaHei', sans-serif; }
                /* çŠ¶æ€æ˜¾ç¤º HUD */
        #hud-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px;
            border: 1px solid rgba(255, 105, 180, 0.3); /* è¾¹æ¡†æ”¹ä¸ºç²‰è‰²ç³» */
            color: #ffb6c1; pointer-events: none; user-select: none;
            z-index: 10; width: 220px;
        }
        #hud-status { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #hud-detail { font-size: 12px; color: #ffb6c1; line-height: 1.5; }

        /* ç§»é™¤æˆ–éšè—è¾“å…¥é¢æ¿ï¼Œä½†ä¿ç•™ä½ç½®é˜²æ­¢ç»“æ„é”™è¯¯ */
        #input-panel {
            display: none; /* ç›´æ¥éšè—è¾“å…¥é¢æ¿ */
        }

        /* éšè—çš„æ‘„åƒå¤´è§†é¢‘ */
        #video-feed { position: absolute; top: 0; left: 0; opacity: 0; z-index: -1; pointer-events: none; }

        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffb6c1; z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <h2>ç²’å­å¿ƒæƒ…ç³»ç»Ÿ V2.0</h2>
        <p>æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´ä¸ AI æ¨¡å‹</p>
        <p style="font-size:12px; color:#666">è¯·ç¡®ä¿ä½¿ç”¨ https æˆ– localhost è®¿é—®</p>
    </div>

    <div id="hud-panel">
        <div id="hud-status">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="hud-detail">
            ğŸ‘† å•æŒ‡ï¼šæ¨±èŠ±+å¼€å¼€å¿ƒå¿ƒ<br>
            âœŒï¸ åŒæŒ‡ï¼šæ¨±èŠ±+å¥½å¥½çˆ±è‡ªå·±<br>
            ğŸ¤Ÿ ä¸‰æŒ‡ï¼šèŠ±ç“£+ä»Šå¤©å¾ˆå“‡å¡<br>
            ğŸ– å¼ æ‰‹ï¼šå˜çˆ±å¿ƒ (è·³åŠ¨)<br>
            âœŠ æ¡æ‹³ï¼šçˆ†ç‚¸+æˆ‘çœŸçš„å¾ˆæ£’
        </div>
    </div>

    <div id="input-panel"></div> 
    <video id="video-feed" playsinline></video>

<script>
    // --- æ ¸å¿ƒé…ç½® ---
    const PARTICLE_COUNT = 30000; 
    const PARTICLE_SIZE = 0.18;

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, particles;
    let particlePositions, colors, targetPositions;
    let geometry;
        
    // çŠ¶æ€æ§åˆ¶
    let isExploding = false;
    let explosionVelocities = [];
    let isTextState = false; 
    let isHeartState = false; // æ–°å¢çˆ±å¿ƒçŠ¶æ€åˆ¤æ–­
    
    // ç”»å¸ƒç›¸å…³
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // æ‰‹åŠ¿çŠ¶æ€æœº
    let lastGesture = 'none';
    let gestureFrameCount = 0;
    const GESTURE_THRESHOLD = 10; 

    // --- é¢„è®¾æ–‡æœ¬ ---
    const PRESET_TEXTS = {
        'one': 'å¼€å¼€å¿ƒå¿ƒ',
        'two': 'å¥½å¥½çˆ±è‡ªå·±',
        'three': 'ä»Šå¤©å¾ˆå“‡å¡',
        'fist': 'æˆ‘çœŸçš„å¾ˆæ£’'
    };

    // --- é¢„è®¾é¢œè‰² ---
    const PRESET_COLORS = {
        'cherry': 0xff69b4, // æ¨±èŠ±ç²‰
        'petal': 0xff4500,  // èŠ±ç“£çº¢
        'heart': 0xff0044, // çˆ±å¿ƒçº¢
        'final': 0x00ffff   // æœ€ç»ˆæ–‡å­—é’è‰²
    };

    // å¯åŠ¨å…¥å£
    initThree();
    initMediaPipe();
    animate();

    // =========================================================
    // 1. THREE.JS ç²’å­ç³»ç»Ÿéƒ¨åˆ†
    // =========================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        initParticles();
        calculateSpherePositions(); 
        window.addEventListener('resize', onWindowResize);
    }

    function initParticles() {
        geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        colors = new Float32Array(PARTICLE_COUNT * 3);
        targetPositions = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlePositions[i*3] = (Math.random()-0.5)*50;
            particlePositions[i*3+1] = (Math.random()-0.5)*50;
            particlePositions[i*3+2] = (Math.random()-0.5)*50;
            colors[i*3] = 0; colors[i*3+1] = 0.8; colors[i*3+2] = 1;
            explosionVelocities.push({x:0, y:0, z:0});
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    // --- æ™ºèƒ½æ–‡å­—è½¬ç²’å­ç®—æ³• (ä¿æŒä¸å˜) ---
    function getTextPositions(textStr, fontSize = 100) {
        ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
        const textWidth = Math.ceil(ctx.measureText(textStr).width);
        const dynamicWidth = textWidth + 60; 
        const dynamicHeight = Math.max(fontSize * 1.5, 200);

        canvas.width = dynamicWidth;
        canvas.height = dynamicHeight;

        ctx.clearRect(0, 0, dynamicWidth, dynamicHeight);
        ctx.fillStyle = 'white';
        ctx.font = `bold ${fontSize}px "Microsoft YaHei"`; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(textStr, dynamicWidth / 2, dynamicHeight / 2);

        const data = ctx.getImageData(0, 0, dynamicWidth, dynamicHeight).data;
        const validPositions = [];

        for (let y = 0; y < dynamicHeight; y += 2) { 
            for (let x = 0; x < dynamicWidth; x += 2) {
                if (data[(y * dynamicWidth + x) * 4 + 3] > 128) {
                    const posX = (x - dynamicWidth / 2) * 0.15; 
                    const posY = -(y - dynamicHeight / 2) * 0.15; 
                    for(let k=0; k<3; k++) {
                        validPositions.push({
                            x: posX,
                            y: posY,
                            z: (Math.random() - 0.5) * 2.5 
                        });
                    }
                }
            }
        }
        return validPositions;
    }

    // --- ã€ä¿®æ”¹ã€‘çˆ±å¿ƒç²’å­ä½ç½®ç”Ÿæˆï¼šå¢åŠ Zè½´æ·±åº¦ï¼Œä½¿å…¶æ›´é¥±æ»¡ ---
    function getHeartPositions() {
        const points = [];
        const particleCountPerHeart = 9000;
        for (let i = 0; i < particleCountPerHeart; i++) {
            const t = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random());
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            
            // å¢å¼º Z è½´éšæœºæ·±åº¦ (é¥±æ»¡åº¦)
            let z = r * 10 * Math.sin(Math.random() * Math.PI * 2) * Math.cos(t); 
            
            x *= 0.35; y *= 0.35; z *= 0.35; y += 2;
            points.push({x, y, z});
        }
        return points;
    }

    // --- å˜å½¢æ ¸å¿ƒé€»è¾‘ (æ–°å¢çˆ±å¿ƒçŠ¶æ€æ§åˆ¶) ---
    function morphTo(newPoints, colorHex, isText = false) {
        isExploding = false;
        isTextState = isText; 
        isHeartState = (newPoints === getHeartPositions); // ç®€æ˜“åˆ¤æ–­æ˜¯å¦ä¸ºå¿ƒå½¢ç›®æ ‡
                
        const colorObj = new THREE.Color(colorHex);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            if (i < newPoints.length) {
                targetPositions[i*3] = newPoints[i].x;
                targetPositions[i*3+1] = newPoints[i].y;
                targetPositions[i*3+2] = newPoints[i].z;
            } else {
                targetPositions[i*3] = (Math.random()-0.5) * 90;
                targetPositions[i*3+1] = (Math.random()-0.5) * 90;
                targetPositions[i*3+2] = (Math.random()-0.5) * 90;
            }
        }

        const startColor = { r: colors[0], g: colors[1], b: colors[2] };
        new TWEEN.Tween(startColor)
            .to({ r: colorObj.r, g: colorObj.g, b: colorObj.b }, 1000)
            .onUpdate(() => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const dim = (i < newPoints.length) ? 1.0 : 0.15; 
                    colors[i*3] = startColor.r * dim;
                    colors[i*3+1] = startColor.g * dim;
                    colors[i*3+2] = startColor.b * dim;
                }
                geometry.attributes.color.needsUpdate = true;
            })
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
            
        // ç¡®ä¿ç²’å­å›åˆ°åˆå§‹ç¼©æ”¾
        particles.scale.set(1, 1, 1);
    }

    // --- é¢„è®¾åŠ¨ä½œå°è£… ---
    function showPresetText(key, color) {
        isHeartState = false; // é€€å‡ºçˆ±å¿ƒçŠ¶æ€
        const text = PRESET_TEXTS[key];
        morphTo(getTextPositions(text, 100), color, true); 
    }

    function morphToHeart() {
        // ä½¿ç”¨ morphTo å‡½æ•°ï¼Œå¹¶è®¾ç½® isHeartState ä¸º true
        morphTo(getHeartPositions(), PRESET_COLORS.heart, false); 
        isHeartState = true; 
    }

    function calculateSpherePositions() {
        isHeartState = false; // é€€å‡ºçˆ±å¿ƒçŠ¶æ€
        const points = [];
        for (let i=0; i<5000; i++) { 
            points.push({x:(Math.random()-0.5)*30, y:(Math.random()-0.5)*30, z:(Math.random()-0.5)*30});
        }
        morphTo(points, PRESET_COLORS.final, false);
    }

    function explodeAndShowMsg() {
        isHeartState = false; // é€€å‡ºçˆ±å¿ƒçŠ¶æ€
        if (isExploding) return;
        isExploding = true;
        isTextState = false; 
                
        for(let i=0; i<PARTICLE_COUNT; i++) {
            explosionVelocities[i].x = (Math.random() - 0.5) * 3.5;
            explosionVelocities[i].y = (Math.random() - 0.5) * 3.5;
            explosionVelocities[i].z = (Math.random() - 0.5) * 3.5;
        }

        setTimeout(() => {
            morphTo(getTextPositions(PRESET_TEXTS.fist, 60), PRESET_COLORS.final, true); 
        }, 1200);
    }
    
    // =========================================================
    // 2. AI æ‰‹åŠ¿è¯†åˆ«éƒ¨åˆ† (ä¿æŒä¸å˜)
    // =========================================================
    function initMediaPipe() {
        const videoElement = document.getElementById('video-feed');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        cameraUtils.start()
            .then(() => {
                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(()=>loader.remove(), 500);
            })
            .catch(err => {
                console.error(err);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ– HTTPS ç¯å¢ƒ");
            });
    }

    function onHandsResults(results) {
        let detectedGesture = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            let fingerCount = 0;
                        
            if (lm[8].y < lm[6].y) fingerCount++; // é£ŸæŒ‡
            if (lm[12].y < lm[10].y) fingerCount++; // ä¸­æŒ‡
            if (lm[16].y < lm[14].y) fingerCount++; // æ— åæŒ‡
            if (lm[20].y < lm[18].y) fingerCount++; // å°æŒ‡
            if (Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x)) fingerCount++; // æ‹‡æŒ‡

            if (fingerCount === 0) detectedGesture = 'fist';
            else if (fingerCount === 1) detectedGesture = 'one';
            else if (fingerCount === 2) detectedGesture = 'two';
            else if (fingerCount === 3) detectedGesture = 'three'; 
            else if (fingerCount >= 4) detectedGesture = 'open'; 
        }

        // é˜²æŠ–é€»è¾‘
        if (detectedGesture === lastGesture) {
            gestureFrameCount++;
        } else {
            gestureFrameCount = 0;
            lastGesture = detectedGesture;
        }

        if (gestureFrameCount === GESTURE_THRESHOLD) {
            handleGestureAction(detectedGesture);
        }
    }

    function handleGestureAction(gesture) {
        const statusDiv = document.getElementById('hud-status');

        switch(gesture) {
            case 'one':
                statusDiv.innerText = "ğŸ‘† è¯†åˆ«ï¼šæ¨±èŠ±+å¼€å¼€å¿ƒå¿ƒ";
                statusDiv.style.color = "#ffb6c1";
                showPresetText('one', PRESET_COLORS.cherry); 
                break;
            case 'two':
                statusDiv.innerText = "âœŒï¸ è¯†åˆ«ï¼šæ¨±èŠ±+å¥½å¥½çˆ±è‡ªå·±";
                statusDiv.style.color = "#ffb6c1";
                showPresetText('two', PRESET_COLORS.cherry); 
                break;
            case 'three':
                statusDiv.innerText = "ğŸ¤Ÿ è¯†åˆ«ï¼šèŠ±ç“£+ä»Šå¤©å¾ˆå“‡å¡";
                statusDiv.style.color = "#ff4500";
                showPresetText('three', PRESET_COLORS.petal); 
                break;
            case 'open':
                statusDiv.innerText = "ğŸ– è¯†åˆ«ï¼šå˜çˆ±å¿ƒ (è·³åŠ¨)";
                statusDiv.style.color = "#ff0044";
                morphToHeart();
                break;
            case 'fist':
                statusDiv.innerText = "âœŠ è¯†åˆ«ï¼šçˆ†ç‚¸+æˆ‘çœŸçš„å¾ˆæ£’";
                statusDiv.style.color = PRESET_COLORS.final;
                explodeAndShowMsg();
                break;
        }
    }

    // =========================================================
    // 3. åŠ¨ç”»å¾ªç¯ (æ–°å¢çˆ±å¿ƒè·³åŠ¨é€»è¾‘)
    // =========================================================
    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();

        const positions = geometry.attributes.position.array;
                
        // æ™ºèƒ½æ—‹è½¬/å›æ­£é€»è¾‘
        if (isTextState) {
            const targetRotation = Math.sin(Date.now() * 0.001) * 0.2;
            particles.rotation.y += (targetRotation - particles.rotation.y) * 0.05;
            particles.scale.set(1, 1, 1); // ç¡®ä¿æ–‡å­—çŠ¶æ€ä¸è·³åŠ¨
        } else if (isHeartState) {
            // ã€æ–°å¢ã€‘çˆ±å¿ƒè·³åŠ¨é€»è¾‘
            const heartBeatScale = 1.0 + Math.abs(Math.sin(Date.now() * 0.005)) * 0.1; // 1.0åˆ°1.1ä¹‹é—´è·³åŠ¨
            particles.scale.set(heartBeatScale, heartBeatScale, heartBeatScale);
            particles.rotation.y += 0.002;
            particles.rotation.y = particles.rotation.y % (Math.PI * 2);
        } else {
            // éæ–‡å­—/éçˆ±å¿ƒçŠ¶æ€ï¼šå…¨æ™¯åŒ€é€Ÿæ—‹è½¬
            particles.scale.set(1, 1, 1);
            particles.rotation.y += 0.002;
            particles.rotation.y = particles.rotation.y % (Math.PI * 2);
        }

        if (isExploding) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3]     += explosionVelocities[i].x;
                positions[i3 + 1] += explosionVelocities[i].y;
                positions[i3 + 2] += explosionVelocities[i].z;
                explosionVelocities[i].x *= 0.92;
                explosionVelocities[i].y *= 0.92;
                explosionVelocities[i].z *= 0.92;
            }
        } else {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const speed = 0.08 + (i % 20) * 0.002; 
                positions[i3]     += (targetPositions[i3]     - positions[i3])     * speed;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * speed;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * speed;
            }
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
