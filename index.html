<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿è¯†åˆ«ä¸ç²’å­æ•ˆæœ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Microsoft YaHei', sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            pointer-events: none;
            z-index: 10;
            width: 220px;
        }

        #hud-status {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            z-index: -1;
            pointer-events: none;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 30px;
            font-weight: bold;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="hud-panel">
        <div id="hud-status">ç­‰å¾…æ‰‹åŠ¿...</div>
    </div>

    <video id="video-feed" playsinline muted></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let lastGesture = 'none';
        let gestureFrameCount = 0;
        const GESTURE_THRESHOLD = 10;

        const videoElement = document.getElementById('video-feed');
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onHandsResults);

        // åŠ è½½æ‘„åƒå¤´
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });

        cameraUtils.start()
            .then(() => {
                console.log("æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ");
            })
            .catch(err => {
                console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", err);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ– HTTPS ç¯å¢ƒ");
            });

        function onHandsResults(results) {
            let detectedGesture = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                let fingerCount = 0;

                // ç¡®å®šå„ä¸ªæ‰‹æŒ‡çš„çŠ¶æ€
                if (lm[8].y < lm[6].y) fingerCount++; // é£ŸæŒ‡
                if (lm[12].y < lm[10].y) fingerCount++; // ä¸­æŒ‡
                if (lm[16].y < lm[14].y) fingerCount++; // æ— åæŒ‡
                if (lm[20].y < lm[18].y) fingerCount++; // å°æŒ‡
                if (Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x)) fingerCount++; // æ‹‡æŒ‡

                // æ›´æ–°æ‰‹åŠ¿
                if (fingerCount === 1) detectedGesture = 'one';
                else if (fingerCount === 2) detectedGesture = 'two';
                else if (fingerCount === 3) detectedGesture = 'three';
                else if (fingerCount >= 4) detectedGesture = 'open';
            }

            console.log('Detected gesture:', detectedGesture);
            if (detectedGesture === lastGesture) {
                gestureFrameCount++;
            } else {
                gestureFrameCount = 0;
                lastGesture = detectedGesture;
            }

            if (gestureFrameCount === GESTURE_THRESHOLD) {
                handleGestureAction(detectedGesture);
            }
        }

        function handleGestureAction(gesture) {
            const statusDiv = document.getElementById('hud-status');

            switch(gesture) {
                case 'one':
                    statusDiv.innerText = "ğŸ‘† è¯†åˆ«ï¼šå•æŒ‡ - æ¨±èŠ±é›¨";
                    statusDiv.style.color = "#ff00ff";
                    createCherryBlossomRain();
                    showMessage("å¼€å¼€å¿ƒå¿ƒ");
                    break;
                case 'two':
                    statusDiv.innerText = "âœŒï¸ è¯†åˆ«ï¼šåŒæŒ‡ - æ¨±èŠ±é›¨";
                    statusDiv.style.color = "#ff00ff";
                    createCherryBlossomRain();
                    showMessage("å¥½å¥½çˆ±è‡ªå·±");
                    break;
                case 'three':
                    statusDiv.innerText = "âœ‹ è¯†åˆ«ï¼šä¸‰æŒ‡ - èŠ±ç“£é›¨";
                    statusDiv.style.color = "#ff00ff";
                    createPetalRain();
                    showMessage("ä»Šå¤©å¾ˆå“‡å¡");
                    break;
                case 'open':
                    statusDiv.innerText = "ğŸ– è¯†åˆ«ï¼šå¼ æ‰‹ - çˆ±å¿ƒ";
                    statusDiv.style.color = "#ff0044";
                    createHeartShape();
                    break;
                case 'fist':
                    statusDiv.innerText = "âœŠ è¯†åˆ«ï¼šæ¡æ‹³ - çˆ†ç‚¸";
                    statusDiv.style.color = "#ffaa00";
                    triggerExplosion();
                    showMessage("æˆ‘çœŸçš„å¾ˆæ£’");
                    break;
            }
        }

        // æ¨±èŠ±é›¨æ•ˆæœ
        function createCherryBlossomRain() {
            const particleCount = 200;
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                particles.push(particle);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(particles);
            const material = new THREE.PointsMaterial({ size: 0.1, color: 0xff00ff, transparent: true });
            const particleSystem = new THREE.Points(geometry, material);
            document.body.appendChild(particleSystem);
            
            // åŠ¨ç”»æ•ˆæœ
            function animate() {
                particles.forEach(p => p.y -= 0.01);
                geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animate);
            }
            animate();
        }

        // èŠ±ç“£é›¨æ•ˆæœ
        function createPetalRain() {
            const particleCount = 200;
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                particles.push(particle);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(particles);
            const material = new THREE.PointsMaterial({ size: 0.1, color: 0xffaa00, transparent: true });
            const particleSystem = new THREE.Points(geometry, material);
            document.body.appendChild(particleSystem);
            
            // åŠ¨ç”»æ•ˆæœ
            function animate() {
                particles.forEach(p => p.y -= 0.01);
                geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animate);
            }
            animate();
        }

        // çˆ±å¿ƒæ•ˆæœ
        function createHeartShape() {
            const particleCount = 200;
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                particles.push(particle);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(particles);
            const material = new THREE.PointsMaterial({ size: 0.1, color: 0xff0044, transparent: true });
            const particleSystem = new THREE.Points(geometry, material);
            document.body.appendChild(particleSystem);
            
            // åŠ¨ç”»æ•ˆæœ
            function animate() {
                particles.forEach(p => p.y -= 0.01);
                geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animate);
            }
            animate();
        }

        // çˆ†ç‚¸æ•ˆæœ
        function triggerExplosion() {
            const particleCount = 500;
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Vector3(
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1,
                    Math.random() * 2 - 1
                );
                particles.push(particle);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(particles);
            const material = new THREE.PointsMaterial({ size: 0.1, color: 0xffaa00, transparent: true });
            const particleSystem = new THREE.Points(geometry, material);
            document.body.appendChild(particleSystem);
            
            // åŠ¨ç”»æ•ˆæœ
            function animate() {
                particles.forEach(p => p.x += Math.random() * 0.1);
                geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animate);
            }
            animate();
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(msg) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.innerText = msg;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 2000);
        }
    </script>

</body>
</html>
