
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ç²’å­è¡¨ç™½ç³»ç»Ÿ - ç¨³å®šäº¤äº’ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* çŠ¶æ€æ˜¾ç¤º HUD */
        #hud-panel {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff; pointer-events: none; user-select: none;
            z-index: 10; width: 220px;
        }
        #hud-status { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #hud-detail { font-size: 12px; color: #aaa; line-height: 1.5; }

        /* è¾“å…¥é¢æ¿ */
        #input-panel {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(20, 20, 30, 0.9); padding: 20px; border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; width: 280px; z-index: 10;
            transition: opacity 0.3s; opacity: 0.3;
        }
        #input-panel:hover { opacity: 1; }
        input {
            width: 100%; padding: 8px; margin-bottom: 10px; border-radius: 4px;
            border: 1px solid #444; background: rgba(0,0,0,0.5); color: white;
            box-sizing: border-box;
        }
        label { font-size: 12px; color: #aaa; display: block; margin-bottom: 5px; }
        
        /* éšè—çš„æ‘„åƒå¤´è§†é¢‘ */
        #video-feed { position: absolute; top: 0; left: 0; opacity: 0; z-index: -1; pointer-events: none; }
        
        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #00ffff; z-index: 999;
            transition: opacity 0.5s;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <h2>ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</h2>
        <p>æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´ä¸ AI æ¨¡å‹</p>
        <p style="font-size:12px; color:#666">è¯·ç¡®ä¿ä½¿ç”¨ https æˆ– localhost è®¿é—®</p>
    </div>

    <div id="hud-panel">
        <div id="hud-status">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="hud-detail">
            ğŸ‘† å•æŒ‡ï¼šç¬¬ä¸€ä¸ªå­—<br>
            âœŒï¸ åŒæŒ‡ï¼šç¬¬äºŒä¸ªå­—<br>
            ğŸ– å¼ æ‰‹ï¼šå˜çˆ±å¿ƒ<br>
            âœŠ æ¡æ‹³ï¼šçˆ†ç‚¸è¡¨ç™½
        </div>
    </div>

    <div id="input-panel">
        <label>åå­—</label>
        <input type="text" id="input-name" value="æå®">
        <label>è¡¨ç™½å†…å®¹</label>
        <input type="text" id="input-msg" value="æˆ‘æ°¸è¿œçˆ±ä½ ">
        <div style="font-size:10px; color:#666; margin-top:5px;">* é¼ æ ‡æ‚¬åœå¯ä¿®æ”¹å†…å®¹</div>
    </div>

    <video id="video-feed" playsinline></video>

<script>
    // --- æ ¸å¿ƒé…ç½® ---
    const PARTICLE_COUNT = 30000; 
    const PARTICLE_SIZE = 0.18;

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, particles;
    let particlePositions, colors, targetPositions;
    let geometry;
    
    // çŠ¶æ€æ§åˆ¶
    let isExploding = false;
    let explosionVelocities = [];
    let isTextState = false; // æ§åˆ¶æ˜¯å¦éœ€è¦æ™ºèƒ½å›æ­£

    // ç”»å¸ƒç›¸å…³
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // æ‰‹åŠ¿çŠ¶æ€æœº
    let lastGesture = 'none';
    let gestureFrameCount = 0;
    const GESTURE_THRESHOLD = 10; 

    // å¯åŠ¨å…¥å£
    initThree();
    initMediaPipe();
    animate();

    // =========================================================
    // 1. THREE.JS ç²’å­ç³»ç»Ÿéƒ¨åˆ†
    // =========================================================
    function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        initParticles();
        calculateSpherePositions(); 
        window.addEventListener('resize', onWindowResize);
    }

    function initParticles() {
        geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        colors = new Float32Array(PARTICLE_COUNT * 3);
        targetPositions = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlePositions[i*3] = (Math.random()-0.5)*50;
            particlePositions[i*3+1] = (Math.random()-0.5)*50;
            particlePositions[i*3+2] = (Math.random()-0.5)*50;
            colors[i*3] = 0; colors[i*3+1] = 0.8; colors[i*3+2] = 1;
            explosionVelocities.push({x:0, y:0, z:0});
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    // --- æ™ºèƒ½æ–‡å­—è½¬ç²’å­ç®—æ³• ---
    function getTextPositions(textStr, fontSize = 100) {
        ctx.font = `bold ${fontSize}px "Microsoft YaHei"`;
        const textWidth = Math.ceil(ctx.measureText(textStr).width);
        
        const dynamicWidth = textWidth + 60; 
        const dynamicHeight = Math.max(fontSize * 1.5, 200);
        
        canvas.width = dynamicWidth;
        canvas.height = dynamicHeight;

        ctx.clearRect(0, 0, dynamicWidth, dynamicHeight);
        ctx.fillStyle = 'white';
        ctx.font = `bold ${fontSize}px "Microsoft YaHei"`; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(textStr, dynamicWidth / 2, dynamicHeight / 2);

        const data = ctx.getImageData(0, 0, dynamicWidth, dynamicHeight).data;
        const validPositions = [];

        for (let y = 0; y < dynamicHeight; y += 2) { 
            for (let x = 0; x < dynamicWidth; x += 2) {
                if (data[(y * dynamicWidth + x) * 4 + 3] > 128) {
                    const posX = (x - dynamicWidth / 2) * 0.15; 
                    const posY = -(y - dynamicHeight / 2) * 0.15; 
                    for(let k=0; k<3; k++) {
                        validPositions.push({
                            x: posX,
                            y: posY,
                            z: (Math.random() - 0.5) * 2.5 
                        });
                    }
                }
            }
        }
        return validPositions;
    }

    function getHeartPositions() {
        const points = [];
        for (let i = 0; i < 9000; i++) {
            const t = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random());
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = r * 6 * Math.sin(Math.random() * Math.PI * 2) * Math.cos(t); 
            x *= 0.35; y *= 0.35; z *= 0.35; y += 2;
            points.push({x, y, z});
        }
        return points;
    }

    // --- å˜å½¢æ ¸å¿ƒé€»è¾‘ ---
    function morphTo(newPoints, colorHex, isText = false) {
        isExploding = false;
        isTextState = isText; 
        
        const colorObj = new THREE.Color(colorHex);
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            if (i < newPoints.length) {
                targetPositions[i*3] = newPoints[i].x;
                targetPositions[i*3+1] = newPoints[i].y;
                targetPositions[i*3+2] = newPoints[i].z;
            } else {
                targetPositions[i*3] = (Math.random()-0.5) * 90;
                targetPositions[i*3+1] = (Math.random()-0.5) * 90;
                targetPositions[i*3+2] = (Math.random()-0.5) * 90;
            }
        }

        const startColor = { r: colors[0], g: colors[1], b: colors[2] };
        new TWEEN.Tween(startColor)
            .to({ r: colorObj.r, g: colorObj.g, b: colorObj.b }, 1000)
            .onUpdate(() => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const dim = (i < newPoints.length) ? 1.0 : 0.15; 
                    colors[i*3] = startColor.r * dim;
                    colors[i*3+1] = startColor.g * dim;
                    colors[i*3+2] = startColor.b * dim;
                }
                geometry.attributes.color.needsUpdate = true;
            })
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
    }

    // --- é¢„è®¾åŠ¨ä½œå°è£… ---
    function showCharacter(index) {
        const name = document.getElementById('input-name').value;
        const char = name[index] || name[name.length-1]; 
        morphTo(getTextPositions(char, 120), 0x00ffff, true); 
    }
    
    // ã€ä¿®æ”¹ã€‘å…¨ååŠŸèƒ½ä¿ç•™é€»è¾‘ï¼Œä½†ç§»é™¤äº†æ‰‹åŠ¿è§¦å‘ï¼Œå¯ä½œä¸ºå¤‡ç”¨
    function showFullName() {
        const name = document.getElementById('input-name').value;
        morphTo(getTextPositions(name, 80), 0x00ffff, true);
    }

    function morphToHeart() {
        morphTo(getHeartPositions(), 0xff0044, false); 
    }

    function calculateSpherePositions() {
        const points = [];
        for (let i=0; i<5000; i++) {
             points.push({x:(Math.random()-0.5)*30, y:(Math.random()-0.5)*30, z:(Math.random()-0.5)*30});
        }
        morphTo(points, 0x00ffff, false);
    }
    
    function explodeAndShowMsg() {
        if (isExploding) return;
        isExploding = true;
        isTextState = false; 
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            explosionVelocities[i].x = (Math.random() - 0.5) * 3.5;
            explosionVelocities[i].y = (Math.random() - 0.5) * 3.5;
            explosionVelocities[i].z = (Math.random() - 0.5) * 3.5;
        }

        setTimeout(() => {
            const msg = document.getElementById('input-msg').value;
            morphTo(getTextPositions(msg, 60), 0xff88aa, true); 
        }, 1200);
    }

    // =========================================================
    // 2. AI æ‰‹åŠ¿è¯†åˆ«éƒ¨åˆ† (æ ¸å¿ƒä¿®æ”¹ï¼šç§»é™¤ä¸‰æŒ‡é€»è¾‘)
    // =========================================================
    function initMediaPipe() {
        const videoElement = document.getElementById('video-feed');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        cameraUtils.start()
            .then(() => {
                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(()=>loader.remove(), 500);
            })
            .catch(err => {
                console.error(err);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ– HTTPS ç¯å¢ƒ");
            });
    }

    function onHandsResults(results) {
        let detectedGesture = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            let fingerCount = 0;
            
            // ç®€æ˜“æ‰‹æŒ‡è®¡æ•°é€»è¾‘
            if (lm[8].y < lm[6].y) fingerCount++; // é£ŸæŒ‡
            if (lm[12].y < lm[10].y) fingerCount++; // ä¸­æŒ‡
            if (lm[16].y < lm[14].y) fingerCount++; // æ— åæŒ‡
            if (lm[20].y < lm[18].y) fingerCount++; // å°æŒ‡
            if (Math.abs(lm[4].x - lm[0].x) > Math.abs(lm[3].x - lm[0].x)) fingerCount++; // æ‹‡æŒ‡

            // --- çŠ¶æ€åˆ†ç±» (ä¼˜åŒ–ç‰ˆ) ---
            if (fingerCount === 0) detectedGesture = 'fist';
            else if (fingerCount === 1) detectedGesture = 'one';
            else if (fingerCount === 2) detectedGesture = 'two';
            // ã€å…³é”®ä¿®æ”¹ã€‘ 3æŒ‡ è¢«è§†ä¸ºæ— æ“ä½œ (æ­»åŒº)ï¼Œé˜²æ­¢è¯¯è§¦
            else if (fingerCount >= 4) detectedGesture = 'open'; // 4æŒ‡æˆ–5æŒ‡éƒ½ç®—å¼ å¼€
        }

        // é˜²æŠ–é€»è¾‘
        if (detectedGesture === lastGesture) {
            gestureFrameCount++;
        } else {
            gestureFrameCount = 0;
            lastGesture = detectedGesture;
        }

        if (gestureFrameCount === GESTURE_THRESHOLD) {
            handleGestureAction(detectedGesture);
        }
    }

    function handleGestureAction(gesture) {
        const statusDiv = document.getElementById('hud-status');

        switch(gesture) {
            case 'one':
                statusDiv.innerText = "ğŸ‘† è¯†åˆ«ï¼šå•æŒ‡";
                statusDiv.style.color = "#00ffff";
                showCharacter(0);
                break;
            case 'two':
                statusDiv.innerText = "âœŒï¸ è¯†åˆ«ï¼šåŒæŒ‡";
                statusDiv.style.color = "#00ffff";
                showCharacter(1);
                break;
            // å·²ç§»é™¤ case 'three'
            case 'open':
                statusDiv.innerText = "ğŸ– è¯†åˆ«ï¼šå¼ æ‰‹";
                statusDiv.style.color = "#ff0044";
                morphToHeart();
                break;
            case 'fist':
                statusDiv.innerText = "âœŠ è¯†åˆ«ï¼šæ¡æ‹³";
                statusDiv.style.color = "#ffaa00";
                explodeAndShowMsg();
                break;
        }
    }

    // =========================================================
    // 3. åŠ¨ç”»å¾ªç¯ (å«æ™ºèƒ½æ—‹è½¬é€»è¾‘)
    // =========================================================
    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();

        const positions = geometry.attributes.position.array;
        
        // --- æ™ºèƒ½æ—‹è½¬é€»è¾‘ ---
        if (isTextState) {
            // æ–‡å­—çŠ¶æ€ï¼šå¹³æ»‘å›æ­£ + å¾®å¹…å‘¼å¸æ‘†åŠ¨
            const targetRotation = Math.sin(Date.now() * 0.001) * 0.2;
            particles.rotation.y += (targetRotation - particles.rotation.y) * 0.05;
        } else {
            // éæ–‡å­—çŠ¶æ€ï¼šå…¨æ™¯åŒ€é€Ÿæ—‹è½¬
            particles.rotation.y += 0.002;
            particles.rotation.y = particles.rotation.y % (Math.PI * 2);
        }

        if (isExploding) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3]     += explosionVelocities[i].x;
                positions[i3 + 1] += explosionVelocities[i].y;
                positions[i3 + 2] += explosionVelocities[i].z;
                explosionVelocities[i].x *= 0.92;
                explosionVelocities[i].y *= 0.92;
                explosionVelocities[i].z *= 0.92;
            }
        } else {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const speed = 0.08 + (i % 20) * 0.002; 
                positions[i3]     += (targetPositions[i3]     - positions[i3])     * speed;
                positions[i3 + 1] += (targetPositions[i3 + 1] - positions[i3 + 1]) * speed;
                positions[i3 + 2] += (targetPositions[i3 + 2] - positions[i3 + 2]) * speed;
            }
        }

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
